# -*- coding: utf-8 -*-
"""searching_sorting.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/92-vasim/dsa-using-python/blob/main/searching_sorting.ipynb
"""

# Linear Searching
# Binary

# Sleep Sort
# Monkey Sort
# Bubble Sort
# Selection
# Merge Sort
# Quick Sort
# Insertion Sort

# Linear Search

# Brute Force

def linear_search(arr,item):

  for i in range(len(arr)):

    if arr[i] == item:
      return i

  return -1

arr = [12,34,56,1,67,100,47,99]

linear_search(arr,121)

# Time Complexity is O(N)
# No sorting required

# Binary Search

# Sorted Array

def binary_search(arr, low, high, item):

  #print("low = ",low,"high = ",high,end=' ')

  if low <= high:
    # search

    mid = (low + high)//2

    #print("mid value is",arr[mid])

    if arr[mid] == item:
      return mid
    elif arr[mid] > item:
      return binary_search(arr, low, mid-1,item)
    else:
      return binary_search(arr,mid+1,high,item)
  else:
    return -1

arr = [12,24,35,46,57,68,80,99,100]
print(binary_search(arr,0,len(arr)-1,-5))

# Sorting

def is_sorted(arr):

  sorted = True

  for i in range(len(arr) - 1):
    if arr[i]>arr[i+1]:
      sorted = False

  return sorted

arr = [1,2,3,4,8,6]
is_sorted(arr)

# Monkey sort

import random
a=[1,2,3,4]
random.shuffle(a)
a

import time
def monkey_sort(arr):

  while not is_sorted(arr):
    time.sleep(1)
    random.shuffle(arr)
    print(arr)
  print(arr)

a = [12,24,11,56,34,20]
monkey_sort(a)

12 24 45 5 16

5 12 16 24 45

def bubble_sort(arr):

  for i in range(len(arr) - 1):
    flag = 0
    for j in range(len(arr) - 1 - i):
      if arr[j] > arr[j+1]:
        arr[j],arr[j+1] = arr[j+1],arr[j]
        flag =1

    if flag == 0:
      break

  return arr

arr = [23,12,34,11,100,56,78]
bubble_sort(arr)

def selection_sort(arr):

  for i in range(len(arr) - 1):

    min = i

    for j in range(i+1,len(arr)):
      if arr[j] < arr[min]:
        min = j

    arr[i],arr[min] = arr[min],arr[i]

  return arr

arr = [23,12,34,11,100,56,78]
selection_sort(arr)

L = []

import random

for i in range(10000):
  L.append(random.randint(1,10000))

len(L)

L1 = L[:]
# cloning

import time

start = time.time()
bubble_sort(L)
print("Time taken",time.time() - start,"secs")

start = time.time()
selection_sort(L1)
print("Time taken",time.time() - start,"secs")

# Not Adaptive

# Merge Sort

def merge_arrays(arr1,arr2):

  i = 0
  j = 0

  new_arr = []

  while i<len(arr1) and j<len(arr2):
    if arr1[i] < arr2[j]:
      new_arr.append(arr1[i])
      i+=1
    else:
      new_arr.append(arr2[j])
      j+=1

  while i < len(arr1):
    new_arr.append(arr1[i])
    i+=1

  while j < len(arr2):
    new_arr.append(arr2[j])
    j+=1

  return new_arr

arr1 = [1,2,6,7,8]
arr2 = [2,3,5]

merge_arrays(arr1,arr2)

def merge_sort(arr):

  mid = len(arr)//2

  left = arr[:mid]
  right = arr[mid:]

  if len(left) == 1 and len(right) == 1:
    return merge_arrays(left,right)
  else:
    merge_sort(left)
    merge_sort(right)

[2,5,1,6,4,7,9,0]
left = [2,5,1,6]
right = [4,7,9,0]

merge sort on left
left1 = [2,5]
right1 = [1,6]

merge on left1
left2 = [2]
right2 = [5]

def quick_sort(arr):

  if len(arr) <= 1:
    return arr

  pivot = arr.pop()

  items_left = []
  items_right = []

  for item in arr:
    if item < pivot:
      items_left.append(item)
    else:
      items_right.append(item)

  return quick_sort(items_left) + [pivot] + quick_sort(items_right)

arr = [2,1,4,6,3,7,5]
quick_sort(arr)

def quick_sort(arr,low,high):

  if len(arr) == 1:
    return arr

  if low < high:

    pi = partition(arr,low,high)

    quick_sort(arr,low,pi-1)
    quick_sort(arr,pi+1,high)

def partition(arr,low,high):

  i = low - 1
  pivot = arr[high]

  for j in range(low,high):

    if arr[j] <= pivot:
      i+=1
      arr[i],arr[j] = arr[j],arr[i]
  arr[i+1],arr[high] = arr[high],arr[i+1]

  return i+1

arr = [10, 7, 8, 9, 1, 5]
n = len(arr)
quick_sort(arr, 0, n-1)
print(arr)

